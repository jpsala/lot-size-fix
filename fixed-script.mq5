// This is a partial script that is used to fix the lot size calculation in the SQ scripts.
// there will be lint errors because this is a partial script and not a full script.
// It's here to help you understand the code and the logic behind the lot size calculation.
// We can make more debug prints to help you understand the code and the logic behind the lot size calculation.

//+------------------------------------------------------------------+
//| Strategy 4.42.100 EA
//|
//|    Generated by StrategyQuant X Build 136 for MetaTrader5 (hedged)
//|    Generated at 07/22/2025 16:12
//| 
//|    Backtested on dax / H1, 2019.01.02 - 2025.07.04 
//+------------------------------------------------------------------+

#property copyright "StrategyQuant.com"
#property link      "http://www.StrategyQuant.com"    
#property strict

#include <Expert/Expert.mqh>
#include <Trade/SymbolInfo.mqh>
#include <Trade/OrderInfo.mqh>
#include <Trade/HistoryOrderInfo.mqh>
#include <Trade/PositionInfo.mqh>
#include <Trade/DealInfo.mqh>
#include <Trade/TerminalInfo.mqh>    
#include <Object.mqh>
#include <MovingAverages.mqh>
#include <Generic\HashMap.mqh>

const int SLPTTYPE_RANGE = 0;
const int SLPTTYPE_LEVEL = 1;

const ENUM_ORDER_TYPE_FILLING preferredFillingType = ORDER_FILLING_FOK;         //preferred filling type - will be applied if available
const bool forceFillingType = false;                                            //if set to true, it will force using preferredFillingType when opening orders

//+------------------------------------------------------------------+
// -- Variables
//+------------------------------------------------------------------+

input string CustomComment = "Strategy_4_42_100";
bool IndicatorLoadedWithoutError = true;
input int MagicNumber = 909352; // Patched on 2025-07-23        //MagicNumber
bool LongEntrySignal = false;        //LongEntrySignal
bool ShortEntrySignal = false;        //ShortEntrySignal
bool LongExitSignal = false;        //LongExitSignal
bool ShortExitSignal = false;        //ShortExitSignal
input int SMAPeriod1 = 46;        //SMAPeriod1
input double ProfitTargetCoef1 = 5;        //ProfitTargetCoef1
input double StopLossCoef1 = 2.62;        //StopLossCoef1
input double TrailingStop1 = 71.94;        //TrailingStop1
input int SMAPeriod2 = 18;        //SMAPeriod2

//+------------------------------------------------------------------+
// Money Management variables
//+------------------------------------------------------------------+
input string smm = "----------- Money Management - Fixed Amount -----------";
input bool UseMoneyManagement = true;
input double mmRiskedMoney = 250.0;
input int mmDecimals = 2;
input double mmLotsIfNoMM = 0.01;
input double mmMaxLots = 1000.0;
input double mmMultiplier = 1.0;
  
  
double sqMMFixedAmount(string symbol, ENUM_ORDER_TYPE orderType, double price, double sl, double RiskedMoney, int decimals, double LotsIfNoMM, double MaximumLots, double multiplier) {
   Verbose("Computing Money Management for order - Fixed amount");
   Verbose("Money risked for this trade: ", DoubleToString(RiskedMoney));
   
   if(UseMoneyManagement == false) {
      Verbose("Use Money Management = false, MM not used");
      return (mmLotsIfNoMM);
   }
      
   string correctedSymbol = correctSymbol(symbol);
   sl = NormalizeDouble(sl, (int) SymbolInfoInteger(correctedSymbol, SYMBOL_DIGITS));
   
   double openPrice = price > 0 ? price : SymbolInfoDouble(correctedSymbol, isLongOrder(orderType) ? SYMBOL_ASK : SYMBOL_BID);
   double LotSize=0;

   if(RiskedMoney <= 0 ) {
      Verbose("Computing Money Management - Incorrect RiskedMoney value, it must be above 0");
      return(0);
   }
   
    
   double Smallest_Lot = SymbolInfoDouble(correctedSymbol, SYMBOL_VOLUME_MIN);
   double Largest_Lot = SymbolInfoDouble(correctedSymbol, SYMBOL_VOLUME_MAX);    
   double LotStep = SymbolInfoDouble(correctedSymbol, SYMBOL_VOLUME_STEP);
		
   // --- FIX START ---
	// Calculate profit/loss for a 1-lot trade to determine the exact drawdown
	double oneLotSLDrawdown;
	if(!OrderCalcProfit(isLongOrder(orderType) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL, correctedSymbol, 1.0, openPrice, sl, oneLotSLDrawdown)) {
		Print("OrderCalcProfit failed. Error: ", GetLastError());
		return 0;
	}
	oneLotSLDrawdown = MathAbs(oneLotSLDrawdown);
	Print(StringFormat("Money to risk: %.2f, One Lot SL Drawdown: %.2f", RiskedMoney, oneLotSLDrawdown));
	// --- FIX END ---
		
   if(oneLotSLDrawdown > 0) {
	  LotSize = roundDown(RiskedMoney / oneLotSLDrawdown, decimals);
   }
   else {
	  LotSize = 0;
   }
   LotSize = LotSize * multiplier;
   //--- MAXLOT and MINLOT management
 
   Verbose("Lot step: ", DoubleToString(LotStep));
   LotSize = floor(LotSize / LotStep) * LotStep;

   Verbose("Computing Money Management - Smallest_Lot: ", DoubleToString(Smallest_Lot), ", Largest_Lot: ", DoubleToString(Largest_Lot), ", Computed LotSize: ", DoubleToString(LotSize));
   Verbose("Money to risk: ", DoubleToString(RiskedMoney), ", One Lot SL Drawdown: ", DoubleToString(oneLotSLDrawdown));

   if(LotSize <= 0) {
      Verbose("Calculated LotSize is <= 0. Using LotsIfNoMM value: ", DoubleToString(LotsIfNoMM), ")");
			LotSize = LotsIfNoMM;
	 }                              

   if (LotSize < Smallest_Lot) {
      Verbose("Calculated LotSize is too small. Minimal allowed lot size from the broker is: ", DoubleToString(Smallest_Lot), ". Please, increase your risk or set fixed LotSize.");
      LotSize = 0;
   }
   else if (LotSize > Largest_Lot) {
      Verbose("LotSize is too big. LotSize set to maximal allowed market value: ", DoubleToString(Largest_Lot));
      LotSize = Largest_Lot;
   }

   if(LotSize > MaximumLots) {
      Verbose("LotSize is too big. LotSize set to maximal allowed value (MaximumLots): ", DoubleToString(MaximumLots));
      LotSize = MaximumLots;
   }

   //--------------------------------------------

   return (LotSize);
}